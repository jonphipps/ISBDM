#!/usr/bin/env python3
import os
import re

import yaml
import argparse
import logging
from collections import defaultdict

# --- Configuration ---
DEFAULT_TARGET_MDX_ROOT = "docs/"  # Where the MDX files with frontmatter are


# --- Utility Functions ---
def setup_logging_illustrative(log_level_str="INFO", log_file="reconstruct_sidebar.log"):
    log_level = getattr(logging, log_level_str.upper(), logging.INFO)
    logging.basicConfig(
        level=log_level,
        format="%(asctime)s [%(levelname)s] %(filename)s:%(lineno)d - %(message)s",
        handlers=[
            logging.FileHandler(log_file, mode='w', encoding='utf-8'),
            logging.StreamHandler()
        ]
    )


def read_front_matter_for_reconstruction(mdx_file_path):
    try:
        with open(mdx_file_path, 'r', encoding='utf-8') as f:
            content = f.read()
    except FileNotFoundError:
        return None

    fm_match = re.match(r'^---\s*?\n(.*?\n)---\s*?\n?(.*)', content, re.DOTALL)
    if fm_match:
        fm_str = fm_match.group(1)
        try:
            fm = yaml.safe_load(fm_str)
            if isinstance(fm, dict):
                # Add path for reference
                fm['_mdx_path'] = mdx_file_path
                return fm
        except yaml.YAMLError as e:
            logging.error(f"YAML error in {mdx_file_path}: {e}")
    return None


def build_tree(items_with_fm):
    """
    Builds a tree from a flat list of items that have sidebar_level and sidebar_position.
    This is a simplified tree builder. A robust one would handle different sections/roots.
    """
    if not items_with_fm:
        return []

    # Sort items first by level, then by position to help with tree construction
    # This assumes sidebar_position is globally unique or unique within a parent scope defined by level.
    # A more robust approach uses parent Pointers if they were stored.
    # For this demo, we'll group by presumed parent based on level and position.

    # For simplicity, this demo will just print them hierarchically based on level.
    # A full tree requires identifying parent-child links.

    # Filter out items that don't have essential sidebar props
    valid_items = [
        item for item in items_with_fm
        if item and 'sidebar_level' in item and 'sidebar_position' in item and 'sidebar_label' in item
    ]

    if not valid_items:
        logging.warning("No valid items with sidebar_level, sidebar_position, and sidebar_label found.")
        return []

    # Sort by position for each level. This is a bit naive without explicit parent links.
    # A real sidebar generator would likely process section by section or use parent references.
    valid_items.sort(key=lambda x: (x.get('sidebar_level', 0), x.get('sidebar_position', 0)))

    # This is a conceptual representation. Generating actual Docusaurus sidebar object
    # requires mapping to Docusaurus types ('category', 'doc', 'autogenerated').

    # For this demo, we will just print in a way that shows hierarchy
    # This is NOT creating a sidebars.js structure directly.

    output_lines = []

    # A very simplified approach to build a conceptual tree for printing
    # Items need to be grouped by parent first.
    # This demo will build a flat list sorted by how Docusaurus might discover them (level, then position)
    # then apply indentation for printing.

    for item in valid_items:
        level = item.get('sidebar_level', 1)
        label = item.get('sidebar_label', 'Unknown Label')
        path = item.get('_mdx_path', 'Unknown Path')
        prefix_str = item.get('customProps', {}).get('sidebar_prefix', '')
        class_name = item.get('sidebar_class_name', '')

        indent = "  " * (level - 1) if level > 0 else ""

        # Try to display the visual prefix if present
        display_label = f"{prefix_str}{label}" if prefix_str else label

        line = f"{indent}- {display_label} (L:{level}, P:{item.get('sidebar_position')}, Class: '{class_name}', Path: {os.path.basename(path)})"
        output_lines.append(line)

    return output_lines


def main_reconstruct():
    parser = argparse.ArgumentParser(
        description="Illustrative script to reconstruct sidebar hierarchy from MDX front matter.")
    parser.add_argument("mdx_root", default=DEFAULT_TARGET_MDX_ROOT, nargs='?', help="Root directory of MDX files.")
    parser.add_argument("--log_level", default="INFO", choices=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
                        help="Logging level.")

    args = parser.parse_args()
    setup_logging_illustrative(args.log_level)

    abs_mdx_root = os.path.abspath(args.mdx_root)
    logging.info(f"Scanning MDX files in: {abs_mdx_root}")

    all_items_fm = []
    for dirpath, _, filenames in os.walk(abs_mdx_root):
        for filename in filenames:
            if filename.endswith(".mdx"):
                mdx_file_path = os.path.join(dirpath, filename)
                fm = read_front_matter_for_reconstruction(mdx_file_path)
                if fm:
                    all_items_fm.append(fm)

    if not all_items_fm:
        logging.info("No MDX files with front matter found.")
        return

    logging.info(f"Found {len(all_items_fm)} MDX files with front matter.")

    # The build_tree function here is simplified for demonstration.
    # A real generator would create a Docusaurus sidebar object.
    reconstructed_tree_lines = build_tree(all_items_fm)

    print("\nReconstructed Sidebar Hierarchy (Illustrative):")
    if reconstructed_tree_lines:
        for line in reconstructed_tree_lines:
            print(line)
    else:
        print("Could not reconstruct a tree (no valid items or tree build failed).")

    print(f"\nNote: This is an illustrative reconstruction based on 'sidebar_level' and 'sidebar_position'.")
    print(f"A production script would generate a Docusaurus 'sidebars.js' compatible object,")
    print(f"likely requiring more sophisticated tree building, especially if 'sidebar_parent_key' is not used.")


def main():
    pass


if __name__ == "__main__":
    # Decide which script to run, or make them separate files.
    # For this example, let's assume the user calls one or the other.
    # This main entry point is for the first script (frontmatter generation)
    # To run the illustrative reconstruction, you'd call main_reconstruct()

    # If you save the second script as, e.g., reconstruct_sidebar_demo.py,
    # you would run that one separately.
    # For now, I'm keeping the main() for the first script.
    main()
    # To test the reconstruction:
    # 1. Run the main script to generate frontmatter.
    # 2. Then, you could call main_reconstruct() or run it as a separate script
    #    pointing to the MDX files.
    # Example:
    # if __name__ == "__main__" and some_condition_to_run_reconstructor:
    # main_reconstruct()