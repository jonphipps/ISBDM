#!/usr/bin/env node

/**
 * Generate element redirects from /docs/elements/{id} to the appropriate category
 * This script scans the four element directories and creates redirect mappings
 * based on the slug (id) in each MDX file's frontmatter
 */

import { readFile, readdir } from 'fs/promises';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import * as yaml from 'js-yaml';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const docsDir = join(__dirname, '..', 'docs');

// Element directories to scan
const ELEMENT_DIRS = ['attributes', 'statements', 'notes', 'relationships'];

/**
 * Extract frontmatter from MDX file
 */
async function extractFrontmatter(filePath) {
  const content = await readFile(filePath, 'utf-8');
  const match = content.match(/^---\n([\s\S]*?)\n---/);
  if (!match) return null;
  
  try {
    return yaml.load(match[1]);
  } catch (e) {
    console.error(`Error parsing frontmatter in ${filePath}:`, e);
    return null;
  }
}

/**
 * Scan a directory for MDX files and extract their IDs
 */
async function scanDirectory(dirName) {
  const dirPath = join(docsDir, dirName);
  const redirects = {};
  
  async function scanDir(currentPath, relativePath = '') {
    const entries = await readdir(currentPath, { withFileTypes: true });
    
    for (const entry of entries) {
      const fullPath = join(currentPath, entry.name);
      
      if (entry.isDirectory()) {
        // Recursively scan subdirectories
        await scanDir(fullPath, join(relativePath, entry.name));
      } else if (entry.name.endsWith('.mdx') && !entry.name.startsWith('_')) {
        const frontmatter = await extractFrontmatter(fullPath);
        
        if (frontmatter && frontmatter.id) {
          // Use the id from frontmatter as the source
          const fromPath = `/docs/elements/${frontmatter.id}`;
          // Build the target path using the actual file location
          const toPath = `/docs/${dirName}/${relativePath ? relativePath + '/' : ''}${frontmatter.id}`;
          redirects[fromPath] = toPath;
        }
      }
    }
  }
  
  try {
    await scanDir(dirPath);
  } catch (e) {
    console.error(`Error scanning directory ${dirName}:`, e);
  }
  
  return redirects;
}

/**
 * Generate all redirects
 */
async function generateRedirects() {
  console.log('Generating element redirects...');
  
  const allRedirects = {};
  
  for (const dir of ELEMENT_DIRS) {
    console.log(`Scanning ${dir}...`);
    const dirRedirects = await scanDirectory(dir);
    Object.assign(allRedirects, dirRedirects);
    console.log(`Found ${Object.keys(dirRedirects).length} elements in ${dir}`);
  }
  
  console.log(`\nTotal redirects generated: ${Object.keys(allRedirects).length}`);
  
  // Generate the redirects configuration
  const redirectsConfig = {
    redirects: Object.entries(allRedirects).map(([from, to]) => ({
      from,
      to,
    }))
  };
  
  // Output as a module that can be imported
  const outputContent = `// Auto-generated by generate-element-redirects.js
// Do not edit manually

export const elementRedirects = ${JSON.stringify(redirectsConfig.redirects, null, 2)};
`;
  
  const outputPath = join(__dirname, 'element-redirects.js');
  await writeFile(outputPath, outputContent);
  console.log(`\nRedirects written to: ${outputPath}`);
  
  return redirectsConfig;
}

// Import writeFile
import { writeFile } from 'fs/promises';

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  generateRedirects().catch(console.error);
}

export { generateRedirects };